---
output: github_document
always_allow_html: true
leafletmap: yes
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE,
  dpi=600,
  fig.width=7)
```

# Computing Activation Zone Boundaries for [SOTA](https://www.sota.org.uk/) Summits in W7W-KG 

<!-- badges: start -->

[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/benmarwick/computing-sota-az-boundaries/master?urlpath=rstudio)

<!-- badges: end -->

### Background

The goal of this repository is to generate polygons that indicate the [activation zones](https://www.sota.org.uk/Blog/2017/07/08/In-The-Zone) for [SOTA](https://www.sota.org.uk/) summits in the W7W-KG area. Here is how the [SOTA FAQ](https://www.sota.org.uk/Joining-In/FAQs) defines the activation zone:

> Q. What is the Activation Zone?

> A. Often it is inconvenient to operate from the actual highest point of a summit, there may be structures there, or on a frequently visited summit there may be too many people about. The SOTA rules permit the operating position to be away from the summit but not more than 25 vertical metres below the summit. If you draw a contour line on a map 25 metres below the summit, the area within this contour is the Activation Zone. See this [MT blog posting](https://www.sota.org.uk/Blog/2017/07/08/In-The-Zone) for more information. If you operate from outside the AZ, the activation is not valid and will score no points.

Prior work on computing activation zones includes: 

- the web app https://activation.zone/ by [Ara N6ARA](https://n6ara.com/) which uses 30m elevation data provided by the [elevation Python package](https://pypi.org/project/elevation/). 
- On [sotl.as](https://sotl.as/) activation zones are visible in the map view for HB/HB0 (calculated using [swissALTI3D](https://www.swisstopo.admin.ch/de/hoehenmodell-swissalti3d) data from swisstopo (spatial resolution 0.5 m, accuracy ± 0.3 – 3 m (1σ) depending on the region) and OE (calculated using BEV ALS DTM data (spatial resolution 1 m, accuracy generally ± 0.5 m, may vary in high altitude). The OE activation zones were computed by [Tobi OE7TOK](https://reflector.sota.org.uk/t/activation-zones-for-oe-on-sotlas/34629). 
- [Caltopo](https://caltopo.com/) can also be used to compute activation zones using the DEM shading tool on a desktop computer or smartphone (see [Tim N7KOM's](https://www.etsy.com/shop/N7KOMPortableRadio) [tutorial](https://www.youtube.com/watch?v=UixA1Fc4D1c) on how to do this). CalTopo's elevation data is up to 1 meter resolution in many areas, which is based on LIDAR scans from the USGS's 3DEP program. This is currently the highest resolution freely available tool for on-the-fly computation of activation zone areas.  

The goal of these project is generate activation zone polygons as GeoJSON files that can be integrated into the sotl.as map. This is inspired by the work done for HB/HB0 and OE, where operators can view the activation zone polygon directly in the sotl.as map  Currently this project only does summits in the W7W-KG area. Here I use the R programming language.

### Acquire the data

Let's load the libraries we'll need

```{r}
library(raster)
library(terra)
library(tidyterra)
library(ggplot2)
library(sf)
library(tidyverse)
library(ggrepel)
library(ggspatial)
```

Import a GeoJSON file containing the locations and elevations of SOTA summits. I got this file from <https://sotl.as/summits/W7W/KG>.

```{r}
# get all summits via the GeoJSON download
gjsf <- st_read("input/W7W_KG.geojson")
```

Extract the location coordinates into columns so we can use them later, and create a column for elevation in meters because our raster data is in meters.

```{r}
# make sf data frame and get coords into cols we can use
gjsf_elev <- 
gjsf %>% 
  mutate(elev_m = parse_number(str_extract(title, ",\\s*(.*?)\\s*m")),
         elev_ft = elev_m * 3.2808399) %>% 
  mutate(x = st_coordinates(geometry)[,"X"],
         y = st_coordinates(geometry)[,"Y"])
```

Create a square buffer area around each summit, with the summit in the center. This is the area that we will download a raster of elevation data to compute the activation zone. This area is good enough for most summits, but for a few summits with very large activation zones it's too small, we'll deal with that later.

```{r}
# make a single square buffer for each point
# Function to create the square buffers
# https://stackoverflow.com/a/70372149/1036500
bSquare <- function(x, a) {
  a <- sqrt(a)/2
  return( sf::st_buffer(x, dist = a, nQuadSegs=1, 
                        endCapStyle = "SQUARE") )
}

# get a buffer zone of a certain area
buffer_side_length <- 1e7 # 100 is a 10x10
gjsf_elev_buf <- 
bSquare(gjsf_elev, buffer_side_length)

gjsf_elev_buf_sq <- vector("list", nrow(gjsf_elev_buf))
for(i in 1:nrow(gjsf_elev_buf)){
  gjsf_elev_buf_sq[[i]] <- 
    st_bbox(gjsf_elev_buf[i,]) %>%
    st_as_sfc() %>%
    st_as_sf()
}

gjsf_elev_buf_sq_df <- 
  bind_rows(gjsf_elev_buf_sq)
```

Take a look at the buffer zones and summit points altogether

```{r}
ggplot() + 
  geom_sf(data = gjsf_elev_buf_sq_df,
          colour = "red", fill = NA) +
  geom_sf(data = gjsf,
          size = 0.1) +
  coord_sf() +
  annotation_scale(location = "bl", 
                   width_hint = 0.5) +
  theme_minimal()
```

Convert the buffer zone into a list of bounding box coordinates to input into the raster download function

```{r}
# get list of bounding boxes coords
gjsf_elev_buf_sq_bbx <- vector("list", nrow(gjsf_elev_buf_sq_df))
for(i in 1:nrow(gjsf_elev_buf_sq_df)){
  gjsf_elev_buf_sq_bbx[[i]] <- 
    gjsf_elev_buf_sq_df$x[i] %>% 
    st_coordinates() %>% 
    as.data.frame() %>% 
    select(X, Y)
}
```

### Iterate over each summit to compute the activation zone polygon
Let's try downloading an entire set of "King County East 2021" DTM Hillshade from https://lidarportal.dnr.wa.gov/ and see if we can read that in and work with that. "King County West 2021" covers just two KG summits, so we need ""King County East 2021" to work on the majority of them. The edge of the raster is quite ragged, so we'll need nieghbouring counties to work on the summits near the edge of King County.  

```{r}
King_County_West_2021_filenames <- 
list.files("~/Downloads/datasetsB", 
           recursive = TRUE, 
           full.names = TRUE,
           pattern = ".tif",
           ignore.case = FALSE)

King_County_East_2021_filenames <- 
list.files("~/Downloads/datasetsB 2", 
           recursive = TRUE, 
           full.names = TRUE,
           pattern = ".tif",
           ignore.case = FALSE)

East_Cascades_South_2020_filenames <- 
list.files("~/Downloads/datasetsB 3", 
           recursive = TRUE, 
           full.names = TRUE,
           pattern = ".tif",
           ignore.case = FALSE)

East_Cascades_North_2020_filenames <- 
list.files("~/Downloads/datasetsB 4", 
           recursive = TRUE, 
           full.names = TRUE,
           pattern = ".tif",
           ignore.case = FALSE)

# import into our R session
# if we get multiple files, we need to merge them
s <- c( #King_County_East_2021_filenames #,
         King_County_West_2021_filenames #,
         # East_Cascades_South_2020_filenames,
         # East_Cascades_North_2020_filenames
          )

m <- sprc(s)
m <- merge(m)

# vrt_file <- terra::vrt(s, "input/vrt.tiff", overwrite=TRUE) 
```

```{r}
# take a quick look at coverage of summits
ggplot() +
  geom_spatraster(data = e) +
  geom_sf(data = gjsf_elev_buf_sq_df, 
          fill = NA) +
  geom_sf(data = gjsf,
          size = 0.1) 
```

```{r}

for(i in 1:length(gjsf_elev_buf_sq_df)){
  
  this_summit <- gjsf_elev[i, ]
  
  this_square <- gjsf_elev_buf_sq_df[i, ]
  
  # transform to projection of LIDAR data
  this_square_nad83 <- st_transform(this_square, st_crs(vrt_file))
  
# subset LIDAR data that fills just this square
  lidar_cropped <- 
    crop(vrt_file, this_square_nad83)
  
  # get max elevation in this area
  lidar_cropped_max_elev <- minmax(lidar_cropped)[2]
  
  az_elev <- 25 # AZ is area -25m elevation from summit
  
# define elevation contour that bounds the AZ
this_summit_point_az <- 
    this_summit %>% 
    mutate(lidar_cropped_max_elev = lidar_cropped_max_elev, # this is helpful for debugging
           az_lower_contour = ifelse(elev_m <= lidar_cropped_max_elev,
                                     elev_m - az_elev,         
                                     lidar_cropped_max_elev - az_elev ),  # SOTA summit data does not always match raster data
           az_lower_contour_ft = az_lower_contour * 3.2808399) 
              
  
ggplot() +
    geom_spatraster(data = lidar_cropped)  +
    geom_sf(data = this_summit,
            colour = "white") +
    geom_sf(data = this_square_nad83, 
            size = 10, 
            colour = "red",
            fill = NA)  
  
  
}



```



